=== tests/cases/conformance/controlFlow/controlFlowOptionalChain.ts ===
// assignments in shortcutting chain
declare const o: undefined | {
>o : Symbol(o, Decl(controlFlowOptionalChain.ts, 1, 13))

    [key: string]: any;
>key : Symbol(key, Decl(controlFlowOptionalChain.ts, 2, 5))

    [key: number]: any;
>key : Symbol(key, Decl(controlFlowOptionalChain.ts, 3, 5))

    (...args: any[]): any;
>args : Symbol(args, Decl(controlFlowOptionalChain.ts, 4, 5))

};

let a: number;
>a : Symbol(a, Decl(controlFlowOptionalChain.ts, 7, 3))

o?.[a = 1];
>o : Symbol(o, Decl(controlFlowOptionalChain.ts, 1, 13))
>a : Symbol(a, Decl(controlFlowOptionalChain.ts, 7, 3))

a.toString();
>a.toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))
>a : Symbol(a, Decl(controlFlowOptionalChain.ts, 7, 3))
>toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))

let b: number;
>b : Symbol(b, Decl(controlFlowOptionalChain.ts, 11, 3))

o?.x[b = 1];
>o : Symbol(o, Decl(controlFlowOptionalChain.ts, 1, 13))
>b : Symbol(b, Decl(controlFlowOptionalChain.ts, 11, 3))

b.toString();
>b.toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))
>b : Symbol(b, Decl(controlFlowOptionalChain.ts, 11, 3))
>toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))

let c: number;
>c : Symbol(c, Decl(controlFlowOptionalChain.ts, 15, 3))

o?.(c = 1)
>o : Symbol(o, Decl(controlFlowOptionalChain.ts, 1, 13))
>c : Symbol(c, Decl(controlFlowOptionalChain.ts, 15, 3))

c.toString();
>c.toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))
>c : Symbol(c, Decl(controlFlowOptionalChain.ts, 15, 3))
>toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))

let d: number;
>d : Symbol(d, Decl(controlFlowOptionalChain.ts, 19, 3))

o?.x(d = 1);
>o : Symbol(o, Decl(controlFlowOptionalChain.ts, 1, 13))
>d : Symbol(d, Decl(controlFlowOptionalChain.ts, 19, 3))

d.toString();
>d.toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))
>d : Symbol(d, Decl(controlFlowOptionalChain.ts, 19, 3))
>toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))

// type predicates
declare const f: undefined | ((x: any) => x is number);
>f : Symbol(f, Decl(controlFlowOptionalChain.ts, 24, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 24, 31))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 24, 31))

declare const x: string | number;
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 25, 13))

if (f?.(x)) {
>f : Symbol(f, Decl(controlFlowOptionalChain.ts, 24, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 25, 13))

    x; // number
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 25, 13))

    f; // TODO: still possibly undefined, should be defined
>f : Symbol(f, Decl(controlFlowOptionalChain.ts, 24, 13))
}
else {
    x; // string | number
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 25, 13))

    f; // still possibly undefined
>f : Symbol(f, Decl(controlFlowOptionalChain.ts, 24, 13))
}
x;
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 25, 13))

f;
>f : Symbol(f, Decl(controlFlowOptionalChain.ts, 24, 13))

declare const o2: { f(x: any): x is number; } | undefined;
>o2 : Symbol(o2, Decl(controlFlowOptionalChain.ts, 37, 13))
>f : Symbol(f, Decl(controlFlowOptionalChain.ts, 37, 19))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 37, 22))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 37, 22))

if (o2?.f(x)) {
>o2?.f : Symbol(f, Decl(controlFlowOptionalChain.ts, 37, 19))
>o2 : Symbol(o2, Decl(controlFlowOptionalChain.ts, 37, 13))
>f : Symbol(f, Decl(controlFlowOptionalChain.ts, 37, 19))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 25, 13))

    x; // number
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 25, 13))

    o2; // TODO: still possibly undefined, should be defined
>o2 : Symbol(o2, Decl(controlFlowOptionalChain.ts, 37, 13))
}
else {
    x; // string | number
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 25, 13))

    o2; // still possibly undefined.
>o2 : Symbol(o2, Decl(controlFlowOptionalChain.ts, 37, 13))
}
x;
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 25, 13))

o2;
>o2 : Symbol(o2, Decl(controlFlowOptionalChain.ts, 37, 13))

declare const o3: { x: 1, y: string } | { x: 2, y: number } | undefined;
>o3 : Symbol(o3, Decl(controlFlowOptionalChain.ts, 49, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 49, 19))
>y : Symbol(y, Decl(controlFlowOptionalChain.ts, 49, 25))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 49, 41))
>y : Symbol(y, Decl(controlFlowOptionalChain.ts, 49, 47))

if (o3?.x === 1) {
>o3?.x : Symbol(x, Decl(controlFlowOptionalChain.ts, 49, 19), Decl(controlFlowOptionalChain.ts, 49, 41))
>o3 : Symbol(o3, Decl(controlFlowOptionalChain.ts, 49, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 49, 19), Decl(controlFlowOptionalChain.ts, 49, 41))

    o3; // TODO: still possibly undefined, should be defined
>o3 : Symbol(o3, Decl(controlFlowOptionalChain.ts, 49, 13))
}
else {
    o3;
>o3 : Symbol(o3, Decl(controlFlowOptionalChain.ts, 49, 13))
}
o3;
>o3 : Symbol(o3, Decl(controlFlowOptionalChain.ts, 49, 13))

declare const o4: { x?: { y: boolean } };
>o4 : Symbol(o4, Decl(controlFlowOptionalChain.ts, 58, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 58, 19))
>y : Symbol(y, Decl(controlFlowOptionalChain.ts, 58, 25))

if (o4.x?.y) {
>o4.x?.y : Symbol(y, Decl(controlFlowOptionalChain.ts, 58, 25))
>o4.x : Symbol(x, Decl(controlFlowOptionalChain.ts, 58, 19))
>o4 : Symbol(o4, Decl(controlFlowOptionalChain.ts, 58, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 58, 19))
>y : Symbol(y, Decl(controlFlowOptionalChain.ts, 58, 25))

    o4.x; // TODO: still possibly undefined, should be defined
>o4.x : Symbol(x, Decl(controlFlowOptionalChain.ts, 58, 19))
>o4 : Symbol(o4, Decl(controlFlowOptionalChain.ts, 58, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 58, 19))

    o4.x.y;
>o4.x.y : Symbol(y, Decl(controlFlowOptionalChain.ts, 58, 25))
>o4.x : Symbol(x, Decl(controlFlowOptionalChain.ts, 58, 19))
>o4 : Symbol(o4, Decl(controlFlowOptionalChain.ts, 58, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 58, 19))
>y : Symbol(y, Decl(controlFlowOptionalChain.ts, 58, 25))
}

interface Base {
>Base : Symbol(Base, Decl(controlFlowOptionalChain.ts, 62, 1))

    f(): this is Derived;
>f : Symbol(Base.f, Decl(controlFlowOptionalChain.ts, 64, 16))
>Derived : Symbol(Derived, Decl(controlFlowOptionalChain.ts, 66, 1))
}

interface Derived extends Base {
>Derived : Symbol(Derived, Decl(controlFlowOptionalChain.ts, 66, 1))
>Base : Symbol(Base, Decl(controlFlowOptionalChain.ts, 62, 1))

    x: number;
>x : Symbol(Derived.x, Decl(controlFlowOptionalChain.ts, 68, 32))
}

declare const o5: Base | undefined;
>o5 : Symbol(o5, Decl(controlFlowOptionalChain.ts, 72, 13))
>Base : Symbol(Base, Decl(controlFlowOptionalChain.ts, 62, 1))

if (o5?.f()) {
>o5?.f : Symbol(Base.f, Decl(controlFlowOptionalChain.ts, 64, 16))
>o5 : Symbol(o5, Decl(controlFlowOptionalChain.ts, 72, 13))
>f : Symbol(Base.f, Decl(controlFlowOptionalChain.ts, 64, 16))

    o5; // Derived
>o5 : Symbol(o5, Decl(controlFlowOptionalChain.ts, 72, 13))
}
else {
    o5; // Base | undefined
>o5 : Symbol(o5, Decl(controlFlowOptionalChain.ts, 72, 13))
}
o5; // Base | undefined
>o5 : Symbol(o5, Decl(controlFlowOptionalChain.ts, 72, 13))

// asserts
declare const isDefined: <T>(value: T) => asserts value is NonNullable<T>;
>isDefined : Symbol(isDefined, Decl(controlFlowOptionalChain.ts, 82, 13))
>T : Symbol(T, Decl(controlFlowOptionalChain.ts, 82, 26))
>value : Symbol(value, Decl(controlFlowOptionalChain.ts, 82, 29))
>T : Symbol(T, Decl(controlFlowOptionalChain.ts, 82, 26))
>value : Symbol(value, Decl(controlFlowOptionalChain.ts, 82, 29))
>NonNullable : Symbol(NonNullable, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(controlFlowOptionalChain.ts, 82, 26))

declare const isString: (value: unknown) => asserts value is string;
>isString : Symbol(isString, Decl(controlFlowOptionalChain.ts, 83, 13))
>value : Symbol(value, Decl(controlFlowOptionalChain.ts, 83, 25))
>value : Symbol(value, Decl(controlFlowOptionalChain.ts, 83, 25))

declare const maybeIsString: undefined | ((value: unknown) => asserts value is string);
>maybeIsString : Symbol(maybeIsString, Decl(controlFlowOptionalChain.ts, 84, 13))
>value : Symbol(value, Decl(controlFlowOptionalChain.ts, 84, 43))
>value : Symbol(value, Decl(controlFlowOptionalChain.ts, 84, 43))

declare const maybeNever: undefined | (() => never);
>maybeNever : Symbol(maybeNever, Decl(controlFlowOptionalChain.ts, 85, 13))

function f01(x: unknown) {
>f01 : Symbol(f01, Decl(controlFlowOptionalChain.ts, 85, 52))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 87, 13))

    if (!!true) {
        isString?.(x);
>isString : Symbol(isString, Decl(controlFlowOptionalChain.ts, 83, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 87, 13))

        x; // string
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 87, 13))
    }
    if (!!true) {
        maybeIsString?.(x);
>maybeIsString : Symbol(maybeIsString, Decl(controlFlowOptionalChain.ts, 84, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 87, 13))

        x; // unknown
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 87, 13))
    }
    if (!!true) {
        isDefined(maybeIsString);
>isDefined : Symbol(isDefined, Decl(controlFlowOptionalChain.ts, 82, 13))
>maybeIsString : Symbol(maybeIsString, Decl(controlFlowOptionalChain.ts, 84, 13))

        maybeIsString?.(x);
>maybeIsString : Symbol(maybeIsString, Decl(controlFlowOptionalChain.ts, 84, 13))
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 87, 13))

        x; // TODO: is unknown, should be string
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 87, 13))
    }
    if (!!true) {
        maybeNever?.();
>maybeNever : Symbol(maybeNever, Decl(controlFlowOptionalChain.ts, 85, 13))

        x; // unknown
>x : Symbol(x, Decl(controlFlowOptionalChain.ts, 87, 13))
    }
}

